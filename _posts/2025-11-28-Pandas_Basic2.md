---
layout: post
title:  "10minutes to Pandas 데이터 선택, 결측치 처리, 연산 중 데이터 선택"
date:   2025-11-28 00:00:00 +0900
categories: Pandas
---
pandas 공식 홈페이지에서 "10minutes to pandas"를 보고 공부 및 번역한 내용입니다.

* 해당 코드는 Visual Studio Code에서 실행하였습니다.
* 오타나 오번역 있을 시 말씀해주시면 수정 반영하겠습니다.

&nbsp;

들어가기에 앞서, Python이나 Numpy 표현식을 사용한 데이터 선택 및 세팅 방법은 직관적이고 상호작용이 필요한 작업일 때 유용하고 편리하지만

반복적이고 안정적으로 실행하기 위한 production code를 위해서

최적화된 pandas 데이터 접근 메서드인 DataFrame.at(), DataFrame.iat(), DataFrame.loc(), DataFrameiloc()를 사용하는게 좋습니다.

&nbsp;

* Pandas에서 Production Code란?
  실제 서비스 환경에서 반복적이고 안정적으로 실행되어야하는 코드를 의미하는데, 이는 규모, 성능, 안정성, 유지보수가 핵심인 코드를 말합니다.

&nbsp;

&nbsp;

지난번에 import한 내용을 다시 기억해내보겠습니다.

```ruby
Import numpy as np
Import pandas as pd

df = pd.DataFrame(np.random.rand(6, 4), index=dates, columns=list("ABCD"")))
df2 = pd.DataFrame(
    {
        "A": 1.0,
        "B": pd.Timestamp("20130102"),
        "C": pd.Series(1, index=list(range(4)), dtype="float32"),
        "D": np.array([3] * 4, dtype="int32"),
        "E": pd.Categorical(["test", "train", "test", "train"]),
        "F": "foo",
    }
)
```

&nbsp;

([])을 사용한 데이터 선택입니다.

DataFrame에서 단일 레이블(문자열)을 전달하여 선택하는 것은 df.A 와 동일한 결과를 갖는 Series 객체를 반환합니다.

```ruby
[In]
print(df["A"])

[Out] 
2013-01-01    0.469112
2013-01-02    1.212112
2013-01-03   -0.861849
2013-01-04    0.721555
2013-01-05   -0.424972
2013-01-06   -0.673690
Freq: D, Name: A, dtype: float64
```

&nbsp;

DataFrame에서 슬라이스(:)를 사용하는 것은 주로 행을 선택하는데 사용됩니다.

이 방식은 python의 리스트 슬라이싱과 비슷하지만 DataFrame의 인덱스 타입에 따라 동작 방식에 약간 차이가 있습니다.

```ruby
[In]
print(df[0:3])

[Out] 
                   A         B         C         D
2013-01-01  0.469112 -0.282863 -1.509059 -1.135632
2013-01-02  1.212112 -0.173215  0.119209 -1.044236
2013-01-03 -0.861849 -2.104569 -0.494929  1.071804

In [26]: df["20130102":"20130104"]
Out[26]: 
                   A         B         C         D
2013-01-02  1.212112 -0.173215  0.119209 -1.044236
2013-01-03 -0.861849 -2.104569 -0.494929  1.071804
2013-01-04  0.721555 -0.706771 -1.039575  0.271860
```

&nbsp;

&nbsp;

레이블을 통한 데이터 선택을 알아보겠습니다.

```ruby
[In]
print(df.loc[dates[0]])

[Out]
A    0.469112
B   -0.282863
C   -1.509059
D   -1.135632
Name: 2013-01-01 00:00:00, dtype: float64
```

&nbsp;

모든 행을 슬라이스(:)를 사용하여 선택하고, 선택된 열 레이블과 함께 선택합니다.

```ruby
[In]
print(df.loc[:, ["A", "B"]])

[Out] 
                   A         B
2013-01-01  0.469112 -0.282863
2013-01-02  1.212112 -0.173215
2013-01-03 -0.861849 -2.104569
2013-01-04  0.721555 -0.706771
2013-01-05 -0.424972  0.567020
2013-01-06 -0.673690  0.113648
```

&nbsp;

레이블 슬라이싱을 위해선 양 끝포인트(시작,끝)이 모두 포함되어야합니다.

```ruby
[In]
print(df.loc["20130102":"20130104", ["A", "B"]])

[Out]
                   A         B
2013-01-02  1.212112 -0.173215
2013-01-03 -0.861849 -2.104569
2013-01-04  0.721555 -0.706771
```

&nbsp;

단일 행 및 열레이블을 선택하면 스칼라 값을 반환합니다.

```ruby
[In]
print(df.loc[dates[0], "A"])

[Out]
0.4691122999071863
```

여기서, 단일 스칼라 값에 빠르게 접근하는 방법입니다.(결과 값은 이전과 같습니다.)

```ruby
[In]
print(df.at[dates[0], "A"])

[Out]
0.4691122999071863
```

* .loc(.iloc)와 .at(.iat)의 차이점으로 .loc(.iloc)는 다중 요소 선택(슬라이싱, 리스트 등)이 가능하지만 .at(.iat)는 오직 단일 행/열 레이블에서 단일 스칼라 값 접근만 가능하다는 것입니다.

&nbsp;

이제 정수 위치를 통한 데이터 선택을 알아보겠습니다.

```ruby
[In]
print(df.iloc[3])

[Out] 
A    0.721555
B   -0.706771
C   -1.039575
D    0.271860
Name: 2013-01-04 00:00:00, dtype: float64
```

.iloc[3]은 행 인덱스 정수 위치 3에 해당하는 행 전체를 선택한다는 의미인데 있는 그대로 읽으면 무슨 말인지 이해가 잘 되지 않습니다.

df.iloc[3]은 DataFrame의 4번째 행을 선택하는 것인데, 정수 위치는 0부터 시작입니다.

따라서, iloc[0] = 1번째 행, iloc[1] = 2번째 행, iloc[2] = 3번째 행, iloc[3] = 4번째 행을 의미합니다.

반환된 값을 살펴보면

```ruby
In [26]: df["20130102":"20130104"]
Out[26]: 
                   A         B         C         D
2013-01-02  1.212112 -0.173215  0.119209 -1.044236
2013-01-03 -0.861849 -2.104569 -0.494929  1.071804
2013-01-04  0.721555 -0.706771 -1.039575  0.271860
```

의 4번째 행인 2013-01-04에 해당하는 A,B,C,D의 값이 출력 된 것을 알 수 있습니다.(맨 위 참고)

&nbsp;

다음으로 정수 슬라이스 (:)의 동작 원리인데, 정수 슬라이스는 NumPy/Python과 유사하게 동작합니다.

```ruby
[In]
print(df.iloc[3:5, 0:2])

[Out] 
                   A         B
2013-01-04  0.721555 -0.706771
2013-01-05 -0.424972  0.567020
```

|  방식  |  접근 기준  | 끝점 포함 여부 |
| :-----: | :---------: | :-------------: |
| .iloc[] |  정수 위치  | 제외(Exclusive) |
| .loc[] | 레이블 이름 | 포함(Inclusive) |

위 표의 내용은 잘 숙지하고 계셔야 합니다.

&nbsp;

정수 위치로 된 리스트를 이용합니다.

```ruby
[In]
print(df.iloc[[1, 2, 4], [0, 2]])

[Out] 
                   A         C
2013-01-02  1.212112  0.119209
2013-01-03 -0.861849 -0.494929
2013-01-05 -0.424972  0.276232
```

.iloc[]를 정수 위치로 접근하게되면 비연속적이거나 특정 순서를 가진 여러 행이나 열을 동시에 선택할 수 있습니다.

특히 DataFrame의 물리적인 위치를 정확히 지정할 때 유용하게 사용됩니다.

&nbsp;

열(cloumns)을 명시적으로 슬라이싱하는 방법입니다.

```ruby
[In]
print(df.iloc[:, 1:3])

[Out] 
                   B         C
2013-01-01 -0.282863 -1.509059
2013-01-02 -0.173215  0.119209
2013-01-03 -2.104569 -0.494929
2013-01-04 -0.706771 -1.039575
2013-01-05  0.567020  0.276232
2013-01-06  0.113648 -1.478427
```

df.iloc[:, 1:3]을 바로 해석하자면 1번 위치(2번째 열)부터 3번 위치 직전(3번째 열)까지의 열을 선택(1,2번 열)하는 것입니다.

그럼 왜 명시적인 슬라이싱이 필요할까요?

df[start:stop]과 같은 기본 [] 연산자는 열 선택이 아닌 행 슬라이싱에 주로 사용되기 때문입니다.

열을 다룰때는 :(모든 행)을 명시하고, loc 또는 iloc를 통해 열 레이블을 지정해주는 것이 오류를 방지하고 코드를 명확하게 만들어주기 때문입니다.

&nbsp;

이제 값(Value)을 명시적으로 얻는 방법입니다.

여기서 값을 명시적으로 얻는다는 의미는 DataFrame 내부의 특정 셀에 있는 단일 스칼라 값을 가장 정확하고 효율적으로 추출하는 것을 의미합니다.

```ruby
[In]
print(df.iloc[1, 1])

[Out]
-0.17321464905330858
```

&nbsp;

그럼, 단일 스칼라 값에 빠르게 접근하는 방법을 알아보겠습니다.

```ruby
[In]
print(df.iat[1, 1])

[Out]
-0.17321464905330858
```

&nbsp;

&nbsp;

불리언 인덱싱(Boolean indexing)이란

불리언 인덱싱은 DataFrame이나 Series에서 특정 조건을 만족하는 데이터만 선택(필터링)하는 강력한 방법입니다.

이 방식은 조건에 따라 True 또는 False 값으로 이루어진 불리언 Series(마스크)를 생성하고 이 마스크를 원본 DataFrame에 적용하여 True인 위치의 행이나 열만

추출합니다.

&nbsp;

첫 번째로 df.A가 0보다 큰 행을 선택해보겠습니다.

```ruby
[In]
print(df[df["A"] > 0])

[Out] 
                   A         B         C         D
2013-01-01  0.469112 -0.282863 -1.509059 -1.135632
2013-01-02  1.212112 -0.173215  0.119209 -1.044236
2013-01-04  0.721555 -0.706771 -1.039575  0.271860
```

&nbsp;

이제 불리언 조건 충족 시 DataFrame 값을 선택해보겠습니다.

```ruby
[In]
print(df[df > 0])

[Out] 
                   A         B         C         D
2013-01-01  0.469112       NaN       NaN       NaN
2013-01-02  1.212112       NaN  0.119209       NaN
2013-01-03       NaN       NaN       NaN  1.071804
2013-01-04  0.721555       NaN       NaN  0.271860
2013-01-05       NaN  0.567020  0.276232       NaN
2013-01-06       NaN  0.113648       NaN  0.524988
```

df[df > 0] 구문은 DataFrame의 모든 셀에 대해 값이 0보다 큰지 확인합니다.

0보다 크다면 True인 원본 값을 유지하고, 0보다 작으면 False인 Nan(결측값)으로 대체합니다.

isin() 메서드를 사용하여 필터링하는 방법입니다.

```ruby
[In]
df2 = df.copy()

[In]
df2["E"] = ["one", "one", "two", "three", "four", "three"]

[In]
print(df2)

[Out] 
                   A         B         C         D      E
2013-01-01  0.469112 -0.282863 -1.509059 -1.135632    one
2013-01-02  1.212112 -0.173215  0.119209 -1.044236    one
2013-01-03 -0.861849 -2.104569 -0.494929  1.071804    two
2013-01-04  0.721555 -0.706771 -1.039575  0.271860  three
2013-01-05 -0.424972  0.567020  0.276232 -1.087401   four
2013-01-06 -0.673690  0.113648 -1.478427  0.524988  three

[In]
print(df2[df2["E"].isin(["two", "four"])])

[Out]: 
                   A         B         C         D     E
2013-01-03 -0.861849 -2.104569 -0.494929  1.071804   two
2013-01-05 -0.424972  0.567020  0.276232 -1.087401  four
```

isin() 메서드는 블리언 인덱싱의 한 종류로 여러 조건 처리(OR)나 목록에 데이터가 포함되어있는지 여부를 빠르게 확인해야할 때 유용하게 사용됩니다.

(참고 : isin() 결과 앞에 ~ 연산자를 붙이면 목록에 포함되지 않는 값들을 선택하는 NOT IN 연산으로 사용할 수 있습니다.)

&nbsp;

새로운 열을 설정(Setting, 생성/할당)할 때 데이터는 인덱스에 의해 자동으로 정렬됩니다.

```ruby
[In]
s1 = pd.Series([1, 2, 3, 4, 5, 6], index=pd.date_range("20130102", periods=6))

[In]
print(s1)

[Out] 
2013-01-02    1
2013-01-03    2
2013-01-04    3
2013-01-05    4
2013-01-06    5
2013-01-07    6
Freq: D, dtype: int64

[In]
df["F"] = s1
```

&nbsp;

레이블을 사용하여 값을 설정합니다.

아래와 같은 방법은 특정 행 레이블과 열 레이블을 명시하여 원하는 셀, 행, 열, 영역에 정확하게 값을 할당하는데 사용합니다.

```ruby
[In]
df.at[dates[0], "A"] = 0
```

정수 위치를 사용하여 값을 설정합니다.

```ruby
[In]
df.iat[0, 1] = 0
```

NumPy 배열을 할당하여 값(Value)을 설정합니다.

```ruby
[In]
df.loc[:, "D"] = np.array([5] * len(df))
```

이전 설정(setting)에 의한 연산 결과입니다.

```ruby
[In]
print(df)

[Out] 
                   A         B         C    D    F
2013-01-01  0.000000  0.000000 -1.509059  5.0  NaN
2013-01-02  1.212112 -0.173215  0.119209  5.0  1.0
2013-01-03 -0.861849 -2.104569 -0.494929  5.0  2.0
2013-01-04  0.721555 -0.706771 -1.039575  5.0  3.0
2013-01-05 -0.424972  0.567020  0.276232  5.0  4.0
2013-01-06 -0.673690  0.113648 -1.478427  5.0  5.0
```

&nbsp;

설정을 포함하는 where 연산입니다.

```ruby
[In]
df2 = df.copy()

[In]
df2[df2 > 0] = -df2

[In]
print(df2)

[Out] 
                   A         B         C    D    F
2013-01-01  0.000000  0.000000 -1.509059 -5.0  NaN
2013-01-02 -1.212112 -0.173215 -0.119209 -5.0 -1.0
2013-01-03 -0.861849 -2.104569 -0.494929 -5.0 -2.0
2013-01-04 -0.721555 -0.706771 -1.039575 -5.0 -3.0
2013-01-05 -0.424972 -0.567020 -0.276232 -5.0 -4.0
2013-01-06 -0.673690 -0.113648 -1.478427 -5.0 -5.0
```

Pandas의 .where() 메서드는 조건을 만족하지 않는 셀의 값을 다른 값으로 대체할 때 사용됩니다.

불리언 인덱싱을 이용한 값 설정과 유사하지만, 조건을 만족하지 않는 경우에 초점을 맞춘다는 차이가 있습니다.

따라서 위 코드는 df2 내에서 값이 0보다 큰 셀만 선택하여 그 값들을 음수(-)로 변환하여 설정하는 것입니다.

&nbsp;

&nbsp;

지금까지 Pandas에서 데이터 선택에 대하여 알아보았습니다.

&nbsp;

감사합니다.
